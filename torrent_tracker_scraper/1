# !/usr/bin/env python
# scrape.py
import binascii
import requests
import logging
import random
import socket
import struct
import time
import io

from loguru import logger as log
from urllib.parse import urlparse
from typing import Callable, List, Tuple


# TODO: Improve log format to include process id
from multiprocessing import Pool

# logging.basicConfig()
# log = logging.getLogger(__name__)
# log.setLevel(logging.DEBUG)

# Protocol says to keep it that way (https://www.bittorrent.org/beps/bep_0015.html)
PROTOCOL_ID = 0x41727101980
# Scrape response offset, first 8 bytes (4 bytes action, 4 bytes connection_id)
OFFSET = 8
# Scrapre response start infohash data
SCRAPE_RESPONSE_BORDER_LEFT: Callable[[int], int] = lambda i: OFFSET + (i * 12) - 12
# Scrapre response end infohash data
SCRAPE_RESPONSE_BORDER_RIGHT: Callable[[int], int] = lambda i: OFFSET + (i * 12)


class TRACKER_ACTION:
    CONNECT = 0
    SCRAPE = 2


def is_infohash_valid(infohash: str) -> bool:
    """
    Checks if the infohash is 20 bytes long, confirming its truly of SHA-1 nature
    :param infohash:
    :return: True if infohash is valid, False otherwise
    """
    if not isinstance(infohash, str):
        return False

    if len(infohash) == 40:
        return True
    return False


def filter_valid_infohashes(infohashes: list) -> list:
    """Returns a list of valid infohashes"""
    return list(filter(lambda i: is_infohash_valid(i), infohashes))


def is_not_blank(s: str) -> bool:
    return bool(s and s.strip())


def get_transaction_id() -> int:
    return random.randrange(1, 65535)


class Connection:
    def __init__(self, hostname, port, timeout):
        self.hostname = hostname
        self.port = port
        self.sock = self.connect(timeout)

    def __str__(self) -> str:
        return f"{self.hostname}:{self.port}"

    def connect(self, timeout):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(timeout)
        try:
            sock.connect((self.hostname, self.port))
        except socket.error as e:
            sock.close()
            log.warning(f"Could not connect to {self}: {e}")
            return None
        return sock


class Scraper:
    def __init__(self, trackers: List = [], infohashes: Tuple[List, str] = [], timeout: int = 10):
        """
        Launches a scraper bound to a particular tracker
        :Keyword Arguments:
            :param trackers (list): An array of trackers in the url format e.g udp://tracker.coppersurfer.tk:6969/announce
            :param infohashes (list): List of infohashes SHA-1 representation of the ```info``` key in the torrent file that should be parsed e.g. 95105D919C10E64AE4FA31067A8D37CCD33FE92D
            :param timeout (int): Timeout value in seconds, program exits if no response received within this period
        """
        self.trackers = trackers
        self.infohashes = infohashes
        self.timeout = timeout

        self.good_infohashes = self.get_good_infohashes()

    def get_good_infohashes(self) -> list:
        if getattr(self, "good_infohashes", None):
            return self.good_infohashes
            
        good_infohashes = []
        if isinstance(self.infohashes, str):
            infohashes_list = self.infohashes.split(",")
            good_infohashes = filter_valid_infohashes(infohashes_list)
        elif isinstance(self.infohashes, list):
            good_infohashes = filter_valid_infohashes(self.infohashes)
        else:
            log.error(f"Infohashes are not supported in type: {type(self.infohashes)}. Only list of strings or comma separated string.")
        return good_infohashes

    def get_trackers(self) -> list:
        if not self.trackers:
            trackers = list()
            # get list of good trackers
            response = requests.get("https://newtrackon.com/api/stable")
            response = io.StringIO(response.text)
            for line in response.readlines():
                if is_not_blank(line):
                    line = line.rstrip()
                    trackers.append(line)
        else:
            trackers = self.trackers
        trackers = list(map(lambda tracker: urlparse(tracker), trackers))
        trackers = list(filter(lambda tracker: tracker.scheme == "udp", trackers))
        return trackers

    def _connect_request(self, transaction_id: int):
        # Send a Connect Request
        packet = struct.pack(">QLL", PROTOCOL_ID, TRACKER_ACTION.CONNECT, transaction_id)
        self.connection.sock.send(packet)
        # Receive a Connect Request response
        
        try:
            res = self.connection.sock.recv(16)
        except ConnectionRefusedError as e:
            res = self.connection.sock.recv(16)

        try:
            _, response_transaction_id, connection_id = struct.unpack(">LLQ", res)
        except struct.error as e:
            log.error(f"Unpacking connect request response failed: {e}")
            raise Exception(f"Unpacking connect request response failed: {e}")

        return response_transaction_id, connection_id

    def _scrape_response(self, transaction_id: int, connection_id: int):
        packet_hashes = self.get_packet_hashes()
        packet = (
            struct.pack(">QLL", connection_id, TRACKER_ACTION.SCRAPE, transaction_id,) + packet_hashes )
        self.connection.sock.send(packet)

        # Scrape response
        try:
            res = self.connection.sock.recv(8 + (12 * len(self.good_infohashes)))
        except socket.timeout as e:
            log.error(f"Socket timeout for {self.connection}: {e}")
            return [f"Socket timeout for {self.connection}: {e}"]

        results = list()
        for i, infohash in enumerate(self.good_infohashes, start=1):
            result = {
                "infohash": infohash,
            }

            response = res[
                SCRAPE_RESPONSE_BORDER_LEFT(i) : SCRAPE_RESPONSE_BORDER_RIGHT(i)
            ]
            if len(response) != struct.calcsize(">LLL"):
                # TODO: Improve error messages
                result["error"] = f"Could not get stats for infohash [{self.connection}]"
                results.append(result)
                log.error(f"Result error: {result}")
                continue
            seeders, completed, leechers = struct.unpack(">LLL", response)
            results.append(
                {
                    "infohash": infohash,
                    "seeders": seeders,
                    "completed": completed,
                    "leechers": leechers,
                }
            )

        return results

    def get_packet_hashes(self) -> bytearray:
        packet_hashes = bytearray(str(), "utf-8")
        for infohash in self.good_infohashes:
            try:
                packet_hashes += binascii.unhexlify(infohash)
            except binascii.Error as e:
                log.warning(f"Infohash {infohash} is invalid. Error when preparing packet hashes: {e}")

        return packet_hashes

    def scrape_tracker(self, tracker):
        """
        To understand how data is retrieved visit: https://www.bittorrent.org/beps/bep_0015.html
        """

        log.debug(f"Parsing list of infohashes [{tracker.netloc}]")
        self.connection = Connection(tracker.hostname, tracker.port, self.timeout)
        tracker_url = f"{tracker.scheme}//:{tracker.netloc}"
        
        # Quit scraping if there is no connection
        if self.connection.sock is None:
            # TODO: Return info which tracker failed
            return []

        # We should get the same value in a response
        transaction_id = get_transaction_id()
        try:
            response_transaction_id, connection_id = self._connect_request(transaction_id)
        except socket.timeout as e:
            log.error(f"Socket timeout for {self.connection}: {e}")
            return [f"Socket timeout for {self.connection}: {e}"]

        if transaction_id != response_transaction_id:
            raise RuntimeError(f"Transaction ID doesnt match in connect request [{self.connectiion}]. Expected {transaction_id}, got {response_transaction_id} ")

        # holds bad error messages
        _bad_infohashes = list()
        for infohash in self.infohashes:
            if not is_infohash_valid(infohash):
                _bad_infohashes.append({"infohash": infohash, "error": "Bad infohash"})

        results = self._scrape_response(transaction_id, connection_id)
        results += _bad_infohashes
        return {"tracker": tracker_url, "results": results}

    def scrape(self):
        """
        Takes in an infohash or infohashes. Returns seeders, leechers and completed
        information
        :param infohashes: SHA-1 representation of the ```info``` key in the torrent file
        :return: [(infohash, seeders, leechers, completed),...]
        """

        print(self.get_good_infohashes())
        self.trackers = self.get_trackers()

        if not self.good_infohashes:
            log.info("Nothing to do. No infohashes passed the checks")
            return 

        log.info(f"Scraping infohashes: {self.good_infohashes}")

        p = Pool()
        results = p.map_async(self.scrape_tracker, self.trackers)
        p.close()
        while True:
            if results.ready():
                break
            time.sleep(0.3)
        results = list(filter(lambda result: result != [], results.get()))

        return results
